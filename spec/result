./integration/staging_running_spec.rb:          "disk" => 128,
./integration/running_app_spec.rb:        "disk" => 128,
./integration/running_java_spec.rb:        "disk" => 1024,
./support/factory.rb:      "limits"              => { "mem" => 1, "disk" => 2, "fds" => 3, "cpu"=>4 },
./support/factory.rb:          "disk" => 128,
./support/registry_shared_examples.rb:      :consuming_disk? => true,
./support/registry_shared_examples.rb:  describe "reserved_disk_bytes" do
./support/registry_shared_examples.rb:    subject { registry.reserved_disk_bytes }
./support/registry_shared_examples.rb:        registry.register(make_instance(:disk_limit_in_bytes => 67))
./support/registry_shared_examples.rb:        registry.register(make_instance(:disk_limit_in_bytes => 67))
./support/registry_shared_examples.rb:        registry.register(make_instance(:disk_limit_in_bytes => 89))
./support/registry_shared_examples.rb:        registry.register(make_instance(:disk_limit_in_bytes => 102))
./support/bootstrap_setup.rb:      "disk" => 10,
./support/integration_helpers/dea_helpers.rb:      "limits" => { "mem" => 1, "disk" => 1 }
./unit/instance_spec.rb:          "limits"   => { "mem" => 1, "disk" => 2, "fds" => 3 },
./unit/instance_spec.rb:      its(:limits)      { should == { "mem" => 1, "disk" => 2, "fds" => 3 } }
./unit/instance_spec.rb:    it "exports the disk limit in bytes" do
./unit/instance_spec.rb:      instance.disk_limit_in_bytes.should == 2048 * 1024
./unit/instance_spec.rb:  describe "consuming_disk?" do
./unit/instance_spec.rb:          instance.consuming_disk?.should be_true
./unit/instance_spec.rb:          instance.consuming_disk?.should be_false
./unit/instance_spec.rb:      instance.stub(:promise_limit_disk).and_return(delivering_promise)
./unit/resource_manager_spec.rb:  let(:disk_mb) { 4000 }
./unit/resource_manager_spec.rb:  let(:disk_overcommit_factor) { 2 }
./unit/resource_manager_spec.rb:  let(:disk_mb) { 1000 }
./unit/resource_manager_spec.rb:  let(:disk_overcommit_factor) { 1 }
./unit/resource_manager_spec.rb:  let(:nominal_disk_capacity) { disk_mb * disk_overcommit_factor }
./unit/resource_manager_spec.rb:      "disk_mb" => disk_mb,
./unit/resource_manager_spec.rb:      "disk_overcommit_factor" => disk_overcommit_factor
./unit/resource_manager_spec.rb:  describe "#remaining_disk" do
./unit/resource_manager_spec.rb:      let(:reserved_instance_disk) { 0 }
./unit/resource_manager_spec.rb:      let(:reserved_staging_disk) { 0 }
./unit/resource_manager_spec.rb:      it "returns the full disk capacity" do
./unit/resource_manager_spec.rb:        manager.remaining_disk.should eql(nominal_disk_capacity)
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 1 }).tap { |i| i.state = "BORN" })
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 2 }).tap { |i| i.state = "STARTING" })
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 4 }).tap { |i| i.state = "RUNNING" })
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 8 }).tap { |i| i.state = "STOPPING" })
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 16 }).tap { |i| i.state = "STOPPED" })
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 32 }).tap { |i| i.state = "CRASHED" })
./unit/resource_manager_spec.rb:        instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 64 }).tap { |i| i.state = "DELETED" })
./unit/resource_manager_spec.rb:      it "returns the correct remaining disk" do
./unit/resource_manager_spec.rb:        manager.remaining_disk.should eql(nominal_disk_capacity - (1 + 2 + 4 + 8 + 32 + 2048))
./unit/resource_manager_spec.rb:    let(:disk_mb) { 4000 }
./unit/resource_manager_spec.rb:    let(:disk_overcommit_factor) { 1 }
./unit/resource_manager_spec.rb:    context "when there is not enough disk to reserve any" do
./unit/resource_manager_spec.rb:  describe "available_disk_ratio" do
./unit/resource_manager_spec.rb:      instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "disk" => 512 }).tap { |i| i.state = "RUNNING" })
./unit/resource_manager_spec.rb:    it "is the ratio of available disk to total disk" do
./unit/resource_manager_spec.rb:      manager.available_disk_ratio.should == 1 - (512.0 + 2048.0) / nominal_disk_capacity
./unit/resource_manager_spec.rb:      instance_registry.register(Dea::Instance.new(bootstrap, "limits" => { "mem" => 512, "disk" => 1024, "cpu"=>50 }).tap { |i| i.state = "RUNNING" })
./unit/resource_manager_spec.rb:      @remaining_disk = nominal_disk_capacity - 1024 - 2048
./unit/resource_manager_spec.rb:      @remaining_cpu = nominal_disk_capacity - 50 - 100
./unit/resource_manager_spec.rb:    context "when the given amounts of memory and disk are available (including extra 'headroom' memory)" do
./unit/resource_manager_spec.rb:        manager.could_reserve?(@remaining_memory - 1, @remaining_disk - 1,@remaining_cpu-1).should be_true
./unit/resource_manager_spec.rb:    context "when too much disk is being used" do
./unit/resource_manager_spec.rb:        manager.could_reserve?(1, @remaining_disk,1).should be_false
./unit/stat_collector_spec.rb:      :disk_stat => Warden::Protocol::InfoResponse::DiskStat.new(
./unit/stat_collector_spec.rb:  its(:used_disk_in_bytes) { should eq 0 }
./unit/stat_collector_spec.rb:      its(:used_disk_in_bytes) { should eq(42) }
./unit/stat_collector_spec.rb:            collector.used_disk_in_bytes,
./unit/stat_collector_spec.rb:          :disk_stat => Warden::Protocol::InfoResponse::DiskStat.new(
./unit/staging_task_spec.rb:  let(:disk_limit_mb) { 1025 }
./unit/staging_task_spec.rb:        "disk_limit_mb" => disk_limit_mb,
./unit/staging_task_spec.rb:         limit_disk
./unit/staging_task_spec.rb:         promise_limit_disk
./unit/staging_task_spec.rb:  describe "#disk_limit_in_bytes" do
./unit/staging_task_spec.rb:    it "exports disk in bytes as specified in the config file" do
./unit/staging_task_spec.rb:      staging.disk_limit_in_bytes.should eq(1024 * 1024 * disk_limit_mb)
./unit/staging_task_spec.rb:        config["staging"].delete("disk_limit_mb")
./unit/staging_task_spec.rb:        staging.disk_limit_in_bytes.should eq(2*1024*1024*1024)
./unit/bootstrap/discovery_spec.rb:        "disk" => 10,
./unit/bootstrap/droplet_information_spec.rb:          "disk_quota" => 10,
./unit/bootstrap/droplet_information_spec.rb:            "disk" => 0,
./unit/bootstrap/droplet_information_spec.rb:        first_instance.stub(:disk_limit_in_bytes).and_return(expected["disk_quota"])
./unit/env_spec.rb:      "limits"              => { "mem" => 1, "disk" => 2, "fds" => 3 },
./unit/bootstrap_spec.rb:      bootstrap.config.stub(:minimum_staging_disk_mb => 444)
./unit/bootstrap_spec.rb:                                      available_disk_ratio: 0,
./unit/bootstrap_spec.rb:      it "is 0 when there is not enough free memory or disk or cpu" do
./unit/bootstrap_spec.rb:      it "is 1 when there is enough memory and disk space" do
./unit/bootstrap_spec.rb:    describe "available_disk_ratio" do
./unit/bootstrap_spec.rb:        bootstrap.resource_manager.stub(:available_disk_ratio).and_return(0.75)
./unit/bootstrap_spec.rb:        VCAP::Component.varz[:available_disk_ratio].should == 0.75
./unit/bootstrap_spec.rb:      let(:extra_attributes) { {"limits" => {"mem" => 1, "disk" => 2, "fds" => 3}} }
./unit/bootstrap_spec.rb:      let(:extra_attributes) { {"limits" => {"mem" => 1, "disk" => 2, "fds" => 3}} }
./unit/task_spec.rb:  describe "#promise_limit_disk" do
./unit/task_spec.rb:      task.stub(:disk_limit_in_bytes).and_return(1234)
./unit/task_spec.rb:      task.promise_limit_disk.resolve
./unit/task_spec.rb:      expect{ task.promise_limit_disk.resolve }.to raise_error(RuntimeError, /error/i)
./unit/task_spec.rb:  describe "#consuming_disk?" do
./unit/task_spec.rb:      expect(task.consuming_disk?).to be_true
./unit/instance_registry_spec.rb:  describe "crash reaping under disk pressure" do
./unit/instance_registry_spec.rb:    it "should reap under disk pressure" do
./unit/instance_registry_spec.rb:      instance_registry.should_receive(:disk_pressure?).and_return(true, false)
./unit/instance_registry_spec.rb:        instance_registry.reap_crashes_under_disk_pressure
./unit/instance_registry_spec.rb:    it "should continue reaping while under disk pressure" do
./unit/instance_registry_spec.rb:      instance_registry.stub(:disk_pressure?).and_return(true)
./unit/instance_registry_spec.rb:        instance_registry.reap_crashes_under_disk_pressure
./unit/instance_registry_spec.rb:  describe "#disk_pressure?" do
./unit/instance_registry_spec.rb:      instance_registry.disk_pressure?.should be_false
./unit/instance_registry_spec.rb:      instance_registry.disk_pressure?.should be_false
./unit/instance_registry_spec.rb:      instance_registry.disk_pressure?.should be_true
./unit/instance_registry_spec.rb:      instance_registry.disk_pressure?.should be_true
